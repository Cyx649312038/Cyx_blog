<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>迭代器 | Cyx～</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/cyx_blog/assets/images/pageLogo.png">
    <meta name="description" content="用于平时学习记录的笔记文档">
    <meta name="author" content="cyx">
    <meta name="Keywords" content="个人笔记">
    
    <link rel="preload" href="/cyx_blog/assets/css/0.styles.3178a8c9.css" as="style"><link rel="preload" href="/cyx_blog/assets/js/app.ebd8d218.js" as="script"><link rel="preload" href="/cyx_blog/assets/js/2.080a46d6.js" as="script"><link rel="preload" href="/cyx_blog/assets/js/33.f9e6634f.js" as="script"><link rel="prefetch" href="/cyx_blog/assets/js/10.d187e49f.js"><link rel="prefetch" href="/cyx_blog/assets/js/11.bfac635a.js"><link rel="prefetch" href="/cyx_blog/assets/js/12.167a9869.js"><link rel="prefetch" href="/cyx_blog/assets/js/13.5e1ef22e.js"><link rel="prefetch" href="/cyx_blog/assets/js/14.266321ac.js"><link rel="prefetch" href="/cyx_blog/assets/js/15.a0db7f52.js"><link rel="prefetch" href="/cyx_blog/assets/js/16.c3bd7f75.js"><link rel="prefetch" href="/cyx_blog/assets/js/17.850a33d5.js"><link rel="prefetch" href="/cyx_blog/assets/js/18.03baacf6.js"><link rel="prefetch" href="/cyx_blog/assets/js/19.e5ecc5cf.js"><link rel="prefetch" href="/cyx_blog/assets/js/20.84e71789.js"><link rel="prefetch" href="/cyx_blog/assets/js/21.0caa4d0f.js"><link rel="prefetch" href="/cyx_blog/assets/js/22.cd5e3d76.js"><link rel="prefetch" href="/cyx_blog/assets/js/23.de7b4abf.js"><link rel="prefetch" href="/cyx_blog/assets/js/24.902ad754.js"><link rel="prefetch" href="/cyx_blog/assets/js/25.4982f003.js"><link rel="prefetch" href="/cyx_blog/assets/js/26.b26cd10d.js"><link rel="prefetch" href="/cyx_blog/assets/js/27.0b792ce1.js"><link rel="prefetch" href="/cyx_blog/assets/js/28.9270dd34.js"><link rel="prefetch" href="/cyx_blog/assets/js/29.5dc2abbe.js"><link rel="prefetch" href="/cyx_blog/assets/js/3.321db5fe.js"><link rel="prefetch" href="/cyx_blog/assets/js/30.718bae68.js"><link rel="prefetch" href="/cyx_blog/assets/js/31.964cb332.js"><link rel="prefetch" href="/cyx_blog/assets/js/32.9da046ff.js"><link rel="prefetch" href="/cyx_blog/assets/js/34.34ac8e0c.js"><link rel="prefetch" href="/cyx_blog/assets/js/35.a763a0be.js"><link rel="prefetch" href="/cyx_blog/assets/js/36.a890cb02.js"><link rel="prefetch" href="/cyx_blog/assets/js/37.1c7e8019.js"><link rel="prefetch" href="/cyx_blog/assets/js/38.a4ab6049.js"><link rel="prefetch" href="/cyx_blog/assets/js/39.1fd5ccb6.js"><link rel="prefetch" href="/cyx_blog/assets/js/4.0704d8fe.js"><link rel="prefetch" href="/cyx_blog/assets/js/40.fe6c7787.js"><link rel="prefetch" href="/cyx_blog/assets/js/41.5a66ba75.js"><link rel="prefetch" href="/cyx_blog/assets/js/42.1d56113a.js"><link rel="prefetch" href="/cyx_blog/assets/js/43.2f654199.js"><link rel="prefetch" href="/cyx_blog/assets/js/44.081f7e06.js"><link rel="prefetch" href="/cyx_blog/assets/js/45.d8c3fbd6.js"><link rel="prefetch" href="/cyx_blog/assets/js/46.f0175cde.js"><link rel="prefetch" href="/cyx_blog/assets/js/5.11b70e0a.js"><link rel="prefetch" href="/cyx_blog/assets/js/6.74c239f2.js"><link rel="prefetch" href="/cyx_blog/assets/js/7.67a47de0.js"><link rel="prefetch" href="/cyx_blog/assets/js/8.e668bce6.js"><link rel="prefetch" href="/cyx_blog/assets/js/9.086a537d.js">
    <link rel="stylesheet" href="/cyx_blog/assets/css/0.styles.3178a8c9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/cyx_blog/" class="home-link router-link-active"><img src="/cyx_blog/assets/images/logo.png" alt="Cyx～" class="logo"> <span class="site-name can-hide">Cyx～</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/cyx_blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/cyx_blog/bookReading/" class="nav-link router-link-active">
  bookReading
</a></div><div class="nav-item"><a href="/cyx_blog/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/cyx_blog/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/cyx_blog/project/" class="nav-link">
  project
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/cyx_blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/cyx_blog/bookReading/" class="nav-link router-link-active">
  bookReading
</a></div><div class="nav-item"><a href="/cyx_blog/typescript/" class="nav-link">
  typescript
</a></div><div class="nav-item"><a href="/cyx_blog/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/cyx_blog/project/" class="nav-link">
  project
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/cyx_blog/bookReading/" class="sidebar-heading clickable router-link-active open"><span>前端书籍阅读</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/cyx_blog/bookReading/dont_know_js 01/" class="sidebar-heading clickable"><span>你不知道的JS(上)</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/cyx_blog/bookReading/dont_know_js 02/" class="sidebar-heading clickable"><span>你不知道的JS(中)</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/cyx_blog/bookReading/dont_know_js 03/" class="sidebar-heading clickable open"><span>你不知道的JS(下)</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/cyx_blog/bookReading/dont_know_js 03/01-grammar.html" class="sidebar-link">1.语法</a></li><li><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html" class="active sidebar-link">2.代码组织</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#迭代器" class="sidebar-link">迭代器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#next迭代" class="sidebar-link">next迭代</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#可选的return-和throw" class="sidebar-link">可选的return（...）和throw(...)</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#迭代器循环" class="sidebar-link">迭代器循环</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#自定义迭代器" class="sidebar-link">自定义迭代器</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#迭代器消耗" class="sidebar-link">迭代器消耗</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#生成器" class="sidebar-link">生成器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#提前完成" class="sidebar-link">提前完成</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#模块" class="sidebar-link">模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#旧方法" class="sidebar-link">旧方法</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#es6模块" class="sidebar-link">es6模块</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#新方法" class="sidebar-link">新方法</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#模块依赖环" class="sidebar-link">模块依赖环</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#模块加载" class="sidebar-link">模块加载</a></li></ul></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#类" class="sidebar-link">类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#class" class="sidebar-link">class</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#extends和super" class="sidebar-link">extends和super</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#new-target" class="sidebar-link">new.target</a></li><li class="sidebar-sub-header"><a href="/cyx_blog/bookReading/dont_know_js 03/02-codeOrganization.html#static" class="sidebar-link">static</a></li></ul></li></ul></li><li><a href="/cyx_blog/bookReading/dont_know_js 03/03-asyncControl.html" class="sidebar-link">3.异步流控制</a></li><li><a href="/cyx_blog/bookReading/dont_know_js 03/04-collection.html" class="sidebar-link">4.集合 </a></li></ul></section></li><li><a href="/cyx_blog/bookReading/javaScriptRedBook/" class="sidebar-link">javaScript程序设计(第四版)</a></li><li><a href="/cyx_blog/bookReading/illustrateHttp/" class="sidebar-link">图解Http</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="迭代器"><a href="#迭代器" class="header-anchor">#</a> 迭代器</h2> <h3 id="next迭代"><a href="#next迭代" class="header-anchor">#</a> next迭代</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { value: 1, done: false }</span>
<span class="token comment">// { value: 2, done: false }</span>
<span class="token comment">// { value: 3, done: false }</span>
<span class="token comment">// { value: 4, done: false }</span>
<span class="token comment">// { value: undefined, done: true }</span>

<span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'cyxtest'</span>
<span class="token keyword">var</span> it2 <span class="token operator">=</span> str<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>it2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { value: 'c', done: false }</span>
<span class="token comment">// { value: 'y', done: false }</span>
<span class="token comment">// ...</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>严格来说，基本值本身不是 iterable，但是感谢“封箱”技术，&quot;hello world&quot; 被强制转换 / 变换为 String 对象封装形式，而这是一个 iterable</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>JavaScript 中默认为(或提供)iterable 的标准内建值包括:</p> <ul><li>Arrays</li> <li>Strings</li> <li>Generators</li> <li>Collections / TypedArrays</li></ul></div> <p>ES6 中还包括几个新的称为集合(参见第 5 章)的数据结构。这些集合不仅本身是 iterable，还提供了 API 方法来产生迭代器，</p> <h3 id="可选的return-和throw"><a href="#可选的return-和throw" class="header-anchor">#</a> 可选的return（...）和throw(...)</h3> <p>多数内置迭代器都没有实现可选的迭代器接口——return(..) 和 throw(..)。然而，在生
成器的上下文中它们肯定是有意义的，参见 3.2 节获取更多信息。</p> <p>return(..) 被定义为向迭代器发送一个信号，表明消费者代码已经完毕，不会再从其中提 取任何值。这个信号可以用于通知生产者(响应 next(..) 调用的迭代器)执行可能需要的 清理工作，比如释放 / 关闭网络、数据库或者文件句柄资源。</p> <p>如果迭代器存在 return(..)，并且出现了任何可以自动被解释为异常或者对迭代器消耗的 提前终止的条件，就会自动调用 return(..)。你也可以手动调用 return(..)。</p> <p>return(..) 就像 next(..) 一样会返回一个 IteratorResult 对象。一般来说，发送给 return(..) 的可选值将会在这个 IteratorResult 中作为 value 返回，但在一些微妙的情况 下并非如此。</p> <p>throw(..) 用于向迭代器报告一个异常 / 错误，迭代器针对这个信号的反应可能不同于针对 return(..) 意味着的完成信号。和对于 return(..) 的反应不一样，它并不一定意味着迭代 器的完全停止。</p> <p>例如，通过生成器迭代器，throw(..) 实际上向生成器的停滞执行上下文中插入了一个抛 出的异常，这个异常可以用 try..catch 捕获。未捕获的 throw(..) 异常最终会异常终止生 成器迭代器。</p> <p>具体代码可以参考你不知道的js(中)生成器那一章</p> <h3 id="迭代器循环"><a href="#迭代器循环" class="header-anchor">#</a> 迭代器循环</h3> <p>ES6 的 for..of 循环直接消耗一个符合规范的 iterable。</p> <p>如果一个迭代器也是一个 iterable，那么它可以直接用于 for..of 循环。你可以通过为迭代 器提供一个 Symbol.iterator 方法简单返回这个迭代器本身使它成为 iterable</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token punctuation">{</span>
<span class="token comment">// 使迭代器it成为iterable </span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
it<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> it<span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// 现在可以用 for..of 循环消耗这个 it 迭代器:</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要彻底理解这样的循环如何工作，可以回顾一下第 2 章 for..of 循环的等价 for 形式:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> v<span class="token punctuation">,</span> res<span class="token punctuation">;</span> <span class="token punctuation">(</span>res <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>res<span class="token punctuation">.</span>done<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    v <span class="token operator">=</span> res<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果认真观察的话，可以看到每次迭代之前都调用了 it.next()，然后查看一下 res.done。 如果 res.done 为 true，表达式求值为 false，迭代就不会发生。</p> <p>回忆一下，前面我们建议迭代器一般不应与最终预期的值一起返回done: true。现在能明 白其中的原因了吧。(先检查状态是否为true再返回value)</p> <p>如果迭代器返回{ done: true, value: 42 }，for..of循环会完全丢弃值42，那么这个 值就被丢失了。因为这个原因，假定你的迭代器可能会通过 for..of 循环或者手动的等价 for形式模式消耗，那么你应该等返回所有的相关迭代值之后，再返回done: true来标明 迭代完毕。</p> <h3 id="自定义迭代器"><a href="#自定义迭代器" class="header-anchor">#</a> 自定义迭代器</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Fib <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使迭代器成为iterable </span>
        <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> current <span class="token operator">=</span> n2<span class="token punctuation">;</span>
            n2 <span class="token operator">=</span> n1<span class="token punctuation">;</span>
            n1 <span class="token operator">=</span> n1 <span class="token operator">+</span> current<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> current<span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
                <span class="token string">&quot;Fibonacci sequence abandoned.&quot;</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> v<span class="token punctuation">,</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> Fib<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&gt;</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1 1 2 3 5 8 13 21 34 55</span>
<span class="token comment">// Fibonacci sequence abandoned.</span>


<span class="token keyword">var</span> something <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> nextVal
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token comment">// for...of循环需要这个</span>
        <span class="token comment">//将 something 的值(迭代器 something 的接口)也构建成为一 个 iterable。现在它既是 iterable，也是迭代器。</span>
        <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">// 标准迭代器接口方法</span>
        <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nextVal <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nextVal <span class="token operator">=</span> <span class="token number">1</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                nextVal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> nextVal<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nextVal <span class="token operator">&gt;</span> <span class="token number">500</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span>
                    <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
                    <span class="token literal-property property">value</span><span class="token operator">:</span> nextVal
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
                <span class="token literal-property property">value</span><span class="token operator">:</span> nextVal
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>


    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> something<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>迭代对象Fib调用Fib<a href="">Symbol.iterator</a> 方法的时候，会返回带有 next() 和 return(..) 方法的迭代器对象。通过放在闭包里的变量 n1 和 n2 维护状态。</p> <h3 id="迭代器消耗"><a href="#迭代器消耗" class="header-anchor">#</a> 迭代器消耗</h3> <p>前面已经展示了如何通过 for..of 循环一个接一个地消耗迭代器项目，但是还有其他 ES6结构可以用来消耗迭代器。</p> <blockquote><p>spread 运算符 ... 完全消耗了迭代器</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">,</span>w<span class="token punctuation">,</span>p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z <span class="token operator">+</span> w <span class="token operator">+</span> p <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token operator">...</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 15</span>
<span class="token comment">// ... 也可以把一个迭代器展开到一个数组中: </span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
b<span class="token punctuation">;</span> <span class="token comment">// [0,1,2,3,4,5,6]</span>
</code></pre></div><blockquote><p>数组解构(参见 2.4 节)可以部分或完全(如果和 rest / gather 运算符 ... 配对使用的话)消耗一个迭代器:</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> it <span class="token operator">=</span> a<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> it<span class="token punctuation">;</span>
<span class="token comment">// 从it中获取前两个元素</span>
<span class="token keyword">var</span> <span class="token punctuation">[</span>z<span class="token punctuation">,</span> <span class="token operator">...</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> it<span class="token punctuation">;</span>
<span class="token comment">// 获取第三个元素，然后一次取得其余所有元素</span>
<span class="token comment">// it已经完全耗尽?是的。</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: undefined, done: true }</span>
x<span class="token punctuation">;</span> <span class="token comment">// 1</span>
y<span class="token punctuation">;</span> <span class="token comment">// 2</span>
z<span class="token punctuation">;</span> <span class="token comment">// 3</span>
w<span class="token punctuation">;</span> <span class="token comment">// [4,5]</span>
</code></pre></div><h2 id="生成器"><a href="#生成器" class="header-anchor">#</a> 生成器</h2> <p>生成器部分具体可以看你不知道的js(中)生成器那章 这里只做一些不太熟悉的内容</p> <p>yield 关键字的优先级很低，几乎 yield.. 之后的任何表达式都会首先计算，然后再 通过 yield 发送。只有 spread 运算符 ... 和逗号运算符 , 拥有更低的优先级，也就是说它们会在 yield 已经被求值之后才会被绑定。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">yield</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 等价于yield (2 + 3)</span>
<span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 首先yield 2，然后+ 3</span>
</code></pre></div><p>yield委托</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;x:&quot;</span><span class="token punctuation">,</span> x <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1 2 3 // x: 4</span>
</code></pre></div><h3 id="提前完成"><a href="#提前完成" class="header-anchor">#</a> 提前完成</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// { value: 1, done: false }</span>
it<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// { value: 42, done: true }</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// { value: undefined, done: true }</span>
</code></pre></div><p>return(x)有点像强制立即执行一个return x，这样就能够立即得到指定值。一旦生成器 完成，或者正常完毕或者像前面展示的那样提前结束，都不会再执行任何代码也不会返回 任何值。</p> <p>return(..) 除了可以手动调用，还可以在每次迭代的末尾被任何消耗迭代器的 ES6 构件自 动调用，比如 for..of 循环和 spread 运算符 ...。</p> <p>这个功能的目的是通知生成器如果控制代码不再在它上面迭代，那么它可能就会执行清理 任务(释放资源、重置状态等)。和普通的函数清理模式相同，完成这一点的主要方式是 通过 finally 子句:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;cleanup!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 1 2 3</span>
<span class="token comment">// cleanup!</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// { value: 1, done: false }</span>
it<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// cleanup!</span>
                     <span class="token comment">// { value: 42, done: true }</span>
</code></pre></div><blockquote><p>提前终止
除了调用 return(..)，还可以调用 throw(..)。正如 return(x) 基本上就是在生成器中的当 前暂停点插入了一个 return x，调用 throw(x) 基本上就相当于在暂停点插入一个 throw x。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// { value: 1, done: false }</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    it<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span> <span class="token string">&quot;Oops!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Exception: Oops!</span>
<span class="token punctuation">}</span> 
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// { value: undefined, done: true }</span>

</code></pre></div><p>因为throw(..)基本上就是在生成器yield 1这一行插入一个throw ..，没有处理这个异 常，所以它会立即传递回调用代码，其中通过 try..catch 处理了这个异常。</p> <p>和 return(..) 不同，迭代器的 throw(..) 方法从来不会被自动调用。 当然，尽管没有在前面代码中展示，如果在调用 throw(..) 的时候有 try..finally 子句在</p> <p>生成器内部等待，那么在异常传回调用代码之前 finally 子句会有机会运行。</p> <h2 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h2> <h3 id="旧方法"><a href="#旧方法" class="header-anchor">#</a> 旧方法</h3> <p>传统的模块模式基于一个带有内部变量和函数的外层函数，以及一个被返回的“publicAPI”，这个“public API”带有对内部数据和功能拥有闭包的方法。通常这样表达:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Hello &quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// public API</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">greeting</span><span class="token operator">:</span> greeting
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> me <span class="token operator">=</span> <span class="token function">Hello</span><span class="token punctuation">(</span> <span class="token string">&quot;Kyle&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
me<span class="token punctuation">.</span><span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// Hello Kyle!</span>

</code></pre></div><p>其中常用的是异步模块定义(Asynchronous Module Definition，AMD)，还有一种是通用模 块定义(Universal Module Definition，UMD)。这里我们不会具体介绍这些模式和技术，但 网上有很多详尽的解释。</p> <h3 id="es6模块"><a href="#es6模块" class="header-anchor">#</a> es6模块</h3> <p>对于 ES6 来说，我们不再需要依赖于封装函数和闭包提供模块支持。ES6 中模块已经具备一等(first class)语法和功能支持。</p> <p>在讨论具体语法细节之前，有一点很重要，就是要理解 ES6 模块和过去我们处理模块的方式之间的显著概念区别。</p> <ul><li>ES6 使用基于文件的模块，也就是说一个文件一个模块。目前，还没有把多个模块合并 到单个文件中的标准方法。
这意味着如果想要把 ES6 模块直接加载到浏览器 Web 应用中，需要分别加载，而不是作 为一大组放在单个文件中加载。在过去，为了性能优化，后者这种加载方式是很常见的。 期待 HTTP/2 的到来能够显著消除所有这样的性能担忧，因为它运行在持久 socket 连接 上，所以能够高效并发、交替加载多个小文件。</li> <li>ES6 模块的 API 是静态的。也就是说，需要在模块的公开 API 中静态定义所有最高层导出， 之后无法补充。
某些应用已经习惯了提供动态 API 定义的能力，可以根据对运行时情况的响应增加 / 删 除 / 替换方法。这些用法或者改变自身以适应 ES6 静态 API，或者需要限制对二级对象 属性 / 方法的动态修改。</li> <li>ES6 模块是单例。也就是说，模块只有一个实例，其中维护了它的状态。每次向其他模 块导入这个模块的时候，得到的是对单个中心实例的引用。如果需要产生多个模块实例， 那么你的模块需要提供某种工厂方法来实现这一点。</li> <li>模块的公开 API 中暴露的属性和方法并不仅仅是普通的值或引用的赋值。它们是到内 部模块定义中的标识符的实际绑定(几乎类似于指针)。
在前 ES6 的模块中，如果把一个持有像数字或者字符串这样的原生值的属性放在公开 API 中，这个属性赋值是通过值复制赋值，任何对于对应变量的内部更新将会是独立
的，不会影响 API 对象的公开复制。</li></ul> <p>对于 ES6 来说，导出一个局部私有变量，即使当前它持有一个原生字符串 / 数字等，导
出的都是到这个变量的绑定。如果模块修改了这个变量的值，外部导入绑定现在会决议
到新的值。</p> <ul><li><p>导入模块和静态请求加载(如果还没加载的话)这个模块是一样的。如果是在浏览器环境中，这意味着通过网络阻塞加载;如果是在服务器上(比如 Node.js)，则是从文件系 统的阻塞加载。</p> <p>但是，不要惊慌于这里的性能暗示。因为 ES6 模块具有静态定义，导入需求可以静态 扫描预先加载，甚至是在使用这个模块之前。</p> <p>关于如何处理这些加载请求，ES6 并没有实际指定或处理具体机制。这里有一个独立的 模块加载器(Module Loader)的概念，其中每个宿主环境(浏览器、Node.js 等)提供 一个适合环境的默认加载器。导入模块时使用一个字符串值表示去哪里获得这个模块(URL、文件路径等)，但是这个值对于你的程序来说是透明的，只对加载器本身有意义。 如果需要提供比默认加载器更细粒度的控制能力可以自定义加载器，默认加载器基本上 没有粒度控制，因为它对于你的程序代码完全是不可见的。</p></li></ul> <blockquote><p>关于CommonJS和ES6 Modules规范请参考下面链接</p></blockquote> <p><a href="https://zhuanlan.zhihu.com/p/27644026" target="_blank" rel="noopener noreferrer">关于CommonJS和ES6 Modules规范<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="新方法"><a href="#新方法" class="header-anchor">#</a> 新方法</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这里有一个很容易被忽略的重要细节:import 和 export 都必须出现在使用 它们的最顶层作用域。举例来说，不能把 import 或 export 放在 if 条件中; 它们必须出现在所有代码块和函数的外面。</p></div> <blockquote><p>导出</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 导出的几种方式</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">var</span> awesome <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span><span class="token punctuation">;</span>

 
<span class="token keyword">var</span> awesome <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> awesome<span class="token punctuation">,</span> bar <span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>这些都称为命名导出(named export)，因为导出变量 / 函数等的名称绑定。</p> <p>在命名导出时还可以“重命名”(也即别名)一个模块成员:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> bar <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>模块导出不是像你熟悉的赋值运算符 = 那样只是值或者引用的普通赋值。实际上，导出的
是对这些东西(变量等)的绑定(类似于指针)。默认导出（export default）导出的有所不同</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">4</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> a<span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>b<span class="token punctuation">}</span>
b <span class="token operator">=</span> <span class="token number">4</span>
<span class="token comment">// export {c as default}</span>

c <span class="token operator">=</span> <span class="token number">5</span>

<span class="token comment">// 另一个文件引入</span>
<span class="token keyword">import</span> c<span class="token punctuation">,</span> <span class="token punctuation">{</span>b<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./02-codeOrganization2.js'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a 1   b 4  c 5</span>
</code></pre></div><p>尽管显然可以在模块定义内部多次使用 export，ES6 绝对倾向于一个模块使用一个 export，称之为默认导出(export default)。每个模块定义只能有一个 default</p> <p>注意下面两种默认导出的细小区别</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">.</span><span class="token punctuation">.</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> foo<span class="token punctuation">;</span>

<span class="token comment">// 2、</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">.</span><span class="token punctuation">.</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在第一段代码中，导出的是此时到函数表达式值的绑定，而不是标识符 foo(引用)。换句话说， export default ..接受的是一个表达式。如果之后在你的模块中给foo赋一个不同的值， 模块导入得到的仍然是原来导出的函数，而不是新的值。
第二段代码中，默认导出绑定实际上绑定到 foo 标识符而不是它的值，所以得 到了前面描述的绑定行为(也就是说，如果之后修改了 foo 的值，在导入一侧看到的值也 会更新)。</p></div> <p>用户可以用import * as ..(名字空间导入，下一小节将会介绍)方法来一次把所有命名导出API引入到某个名字空间中。</p> <blockquote><p>导入</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 导入某些特定命名导出</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 你可以对导入绑定标识符重命名</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> theFooFunc <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token function">theFooFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>如果这个模块只有一个你想要导入并绑定到一个标识符的默认导出，绑定时可以省略包围 的 { .. } 语法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 或者完整形式但这种用的不多:</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>前面一小节介绍过，模块的 export 中的关键字 default 指定了一个命名导 出，名称实际上就是 default，</p></div> <p>你还可以把默认导出与其他命名导出一起导入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 导出文件</span>
 <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment">// 导入文件</span>
 <span class="token keyword">import</span> <span class="token constant">FOOFN</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> bar<span class="token punctuation">,</span> baz <span class="token keyword">as</span> <span class="token constant">BAZ</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token constant">FOOFN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">BAZ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>导入所有模块</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 导出文件</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> a <span class="token operator">=</span> <span class="token number">3</span>
<span class="token comment">// 导入文件</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> foo <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 或者（这种比较常用）</span>
<span class="token comment">// import a , * as foo from &quot;foo&quot;</span>
foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>x<span class="token punctuation">;</span>          <span class="token comment">// 42</span>
foo<span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span>default  <span class="token comment">//3</span>

</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>如果通过 * as .. 导入的模块有默认导出，它在指定的命名空间中的名字就是 default。</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>所有导入的绑定都是不可变和 / 或只读的。</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> foofn<span class="token punctuation">,</span> <span class="token operator">*</span> <span class="token keyword">as</span> hello <span class="token keyword">from</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
foofn <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
hello<span class="token punctuation">.</span>default <span class="token operator">=</span> <span class="token number">42</span>  <span class="token comment">// (运行时)TypeError!;</span>
hello<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment">// (运行时)TypeError!</span>
hello<span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token comment">// (运行时)TypeError!</span>
</code></pre></div><p>作为 import 结果的声明是“提升的”</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 合法</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>import 最基本的形式是这样的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">'foo'</span>
</code></pre></div><p>这种形式并没有实际导入任何一个这个模块的绑定到你的作用域。它加载(如果还没有加 载的话)、编译(如果还没有编译的话)，并求值(如果还没有运行的话)&quot;foo&quot; 模块。</p> <h3 id="模块依赖环"><a href="#模块依赖环" class="header-anchor">#</a> 模块依赖环</h3> <h3 id="模块加载"><a href="#模块加载" class="header-anchor">#</a> 模块加载</h3> <h2 id="类"><a href="#类" class="header-anchor">#</a> 类</h2> <h3 id="class"><a href="#class" class="header-anchor">#</a> class</h3> <p>新的 ES6 类机制的核心是关键字 class，表示一个块，其内容定义了一个函数原型的成员。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> b<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token function">gimmeXY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>需要注意以下几点</p> <ul><li>class Foo 表明创建一个(具体的)名为 Foo 的函数，与你在前 ES6 中所做的非常类似。</li> <li>constructor(..) 指定 Foo(..) 函数的签名以及函数体内容。</li> <li>类方法使用第 2 章讨论过的对象字面量可用的同样的“简洁方法”语法。这也包含本章
前面讨论过的简洁生成器形式，以及 ES5 getter/setter 语法。但是，类方法是不可枚举的，
而对象方法默认是可枚举的。</li> <li>和对象字面量不一样，在 class 定义体内部不用逗号分隔成员!实际上，这甚至是不允
许的。</li></ul> <p>可以把前面代码中的 class 语法定义粗略理解为下面这个等价前 ES6 代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">gimmeXY</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意!尽管 class Foo 看起来很像 function Foo()，但二者有重要区别。</p> <ul><li>由于前 ES6 可用的 Foo.call(obj) 不能工作，class Foo 的 Foo(..) 调用必须通过 new 来实现。</li> <li>function Foo是“提升的”(参见本系列《你不知道的JavaScript(上卷)》第一部分)， 而class Foo并不是;extends ..语句指定了一个不能被“提升”的表达式。所以，在 实例化一个 class 之前必须先声明它。</li> <li>全局作用域中的class Foo创建了这个作用域的一个词法标识符Foo，但是和function Foo 不一样，并没有创建一个同名的全局对象属性。</li></ul> <p>因为 class 只是创建了一个同名的构造器函数，所以现有的 instanceof 运算符对 ES6 类 仍然可以工作。然而，ES6 引入了一种使用 Symbol.hasInstance(参见 7.3 节)自定义 instanceof 如何工作的方法。</p> <h3 id="extends和super"><a href="#extends和super" class="header-anchor">#</a> extends和super</h3> <p>ES6 类还通过面向类的常用术语 extends 提供了一个语法糖，用来在两个函数原型之间 建立 [[Prototype]] 委托链接——通常被误称为“继承”或者令人迷惑地标识为“原型 继承”:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    <span class="token function">gimmeXYZ</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">gimmeXY</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>z<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">25</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre></div><p>还有一个重要的新增特性是 super,在构造器中，super 自动指向“父构造器”，在前面的例子中 就是 Foo(..)。在方法中，super 会指向“父对象”，这样就可以访问其属性</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Bar extends Foo 的意思当然就是把 Bar.prototype 的 [[Prototype]] 连接到 Foo.prototype。 所以，在像 gimmeXYZ() 这样的方法中，super 具体指 Foo.prototype，而在 Bar 构造器中 super 指的是 Foo</p></div> <blockquote><p>super恶龙</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">class</span> <span class="token class-name">ParentA</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;ParentA:&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ParentB</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;ParentB:&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ChildA</span> <span class="token keyword">extends</span> <span class="token class-name">ParentA</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;ChildA:&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ChildB</span> <span class="token keyword">extends</span> <span class="token class-name">ParentB</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;ChildB:&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChildA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChildB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ParentA: a</span>
<span class="token comment">// ChildA: a</span>
<span class="token comment">// ParentB: b</span>
<span class="token comment">// ChildB: b</span>

<span class="token comment">// 在a的上下文中借来b.foo()使用 </span>
b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ParentB: a</span>
                <span class="token comment">// ChildB: a</span>
</code></pre></div><p>可以看到，this.id引用被动态重新绑定，因此两种情况下都打印: a，而不是: b。但是 b.foo() 的 super.foo() 引用没有被动态重绑定，所以它仍然打印出 ParentB 而不是期望的 ParentA。</p> <p>因为 b.foo() 引用了 super，它是静态绑定到 ChildB/ParentB 类层次的，而不能用在 ChildA / ParentA 类层次。ES6 并没有对这个局限提供解决方案。</p> <blockquote><p>子类构造器
对于类和子类来说，构造器并不是必须的;如果省略的话那么二者都会自动提供一个默认 构造器。但是，这个默认替代构造器对于直接类和扩展类来说有所不同。</p></blockquote> <p>具体来说，默认子类构造器自动调用父类的构造器并传递所有参数。换句话说，可以把默 认子类构造器看成下面这样:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一个需要注意的重要细节。并不是在所有支持类的语言中子类构造器都会自动调用 父类构造器。C++ 会这样，Java 则不然。更重要的是，在前 ES6 的类中，并不存在这样 的自动“父类构造器”调用</p> <p>另外一个 ES6 子类构造器或许是出乎意料的偏离 / 限制是:子类构造器中调用 super(..) 之后才能访问 this。其原因比较微妙复杂，但可以归结为创建 / 初始化你的实例 this 的实 际上是父构造器。前 ES6 中，它的实现正相反;this 对象是由“子类构造器”创建的，然 后在子类的 this 上下文中调用“父类”构造器。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 下面来说明一下。以下代码在前 ES6 中可以工作:</span>
<span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">Foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">this</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// `Bar` &quot;extends&quot; `Foo`</span>
<span class="token class-name">Bar</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 而这个等价 ES6 代码则不合法:</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 不允许在super()之前</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 要改正的话可以交换这两条语句</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>扩展原生类
新的 class 和 extend 设计带来的最大好处之一是(终于 !)可以构建内置类的子类了。比 如 Array。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyCoolArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span>
    <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCoolArray</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>
a<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 </span>
a<span class="token punctuation">.</span><span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre></div><p>在 ES6 之前，有一个 Array 的伪“子类”通过手动创建对象并链接到 Array.prototype，只 能部分工作。它不支持真正 array 的特有性质，比如自动更新 length 属性。ES6 子类则可 以完全按照期望“继承”并新增特性!</p> <p>其他还有Error对象等...</p> <h3 id="new-target"><a href="#new-target" class="header-anchor">#</a> new.target</h3> <p>ES6 以 new.target 的形式引入了一个新概念，称为元属性(meta property，参见第 7 章)。</p> <p>new.target 是一个新的在所有函数中都可用的“魔法”值，尽管在一般函数中它通常是 undefined。在任何构造器中，new.target 总是指向 new 实际上直接调用的构造器，即使构 造器是在父类中且通过子类构造器用 super(..) 委托调用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Foo: &quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Bar: &quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;baz: &quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Foo: Foo</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Foo: Bar &lt;-- 遵循new调用点 // Bar: Bar</span>
b<span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// baz: undefined</span>
</code></pre></div><p>除了访问静态属性 / 方法(参见下一小节)之外，类构造器中的 new.target 元属性没有什 么其他用处。</p> <p>如果 new.target 是 undefined，那么你就可以知道这个函数不是通过 new 调用的。因此如果需要的话可以强制一个 new 调用。</p> <h3 id="static"><a href="#static" class="header-anchor">#</a> static</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">cool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;cool&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">wow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;wow&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">awesome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">cool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;awesome&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">neat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">wow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;neat&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Foo<span class="token punctuation">.</span><span class="token function">cool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;cool&quot;</span>
Bar<span class="token punctuation">.</span><span class="token function">cool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;cool&quot;</span>
Bar<span class="token punctuation">.</span><span class="token function">awesome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;cool&quot;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;awesome&quot;</span>
b<span class="token punctuation">.</span><span class="token function">neat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;wow&quot;  &quot;neat&quot;</span>
b<span class="token punctuation">.</span>awesome<span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
b<span class="token punctuation">.</span>cool<span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/22/2022, 9:02:49 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cyx_blog/bookReading/dont_know_js 03/01-grammar.html" class="prev">
        1.语法
      </a></span> <span class="next"><a href="/cyx_blog/bookReading/dont_know_js 03/03-asyncControl.html">
        3.异步流控制
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/cyx_blog/assets/js/app.ebd8d218.js" defer></script><script src="/cyx_blog/assets/js/2.080a46d6.js" defer></script><script src="/cyx_blog/assets/js/33.f9e6634f.js" defer></script>
  </body>
</html>
